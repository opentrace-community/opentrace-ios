/*
 * Copyright 2019 Google
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: wireless/android/config/proto/config.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "FirebaseRemoteConfig/Sources/Protos/wireless/android/config/proto/Config.pbobjc.h"
//#import "FirebaseRemoteConfig/Sources/Protos/logs/wireless/android/AndroidConfig.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - RCNConfigRoot

@implementation RCNConfigRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - RCNConfigRoot_FileDescriptor

static GPBFileDescriptor *RCNConfigRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"android.config"
                                                 objcPrefix:@"RCN"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum RCNConfigDeviceType

GPBEnumDescriptor *RCNConfigDeviceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Android\000Ios\000ChromeBrowser\000Chrome"
        "Os\000Desktop\000";
    static const int32_t values[] = {
        RCNConfigDeviceType_Unknown,
        RCNConfigDeviceType_Android,
        RCNConfigDeviceType_Ios,
        RCNConfigDeviceType_ChromeBrowser,
        RCNConfigDeviceType_ChromeOs,
        RCNConfigDeviceType_Desktop,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RCNConfigDeviceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RCNConfigDeviceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RCNConfigDeviceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RCNConfigDeviceType_Unknown:
    case RCNConfigDeviceType_Android:
    case RCNConfigDeviceType_Ios:
    case RCNConfigDeviceType_ChromeBrowser:
    case RCNConfigDeviceType_ChromeOs:
    case RCNConfigDeviceType_Desktop:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RCNPackageData

@implementation RCNPackageData

@dynamic hasVersionCode, versionCode;
@dynamic hasDigest, digest;
@dynamic hasCertHash, certHash;
@dynamic hasProjectId, projectId;
@dynamic hasPackageName, packageName;
@dynamic hasGmpProjectId, gmpProjectId;
@dynamic hasGamesProjectId, gamesProjectId;
@dynamic namespaceDigestArray, namespaceDigestArray_Count;
@dynamic customVariableArray, customVariableArray_Count;
@dynamic hasAppCertHash, appCertHash;
@dynamic hasAppVersionCode, appVersionCode;
@dynamic hasAppVersion, appVersion;
@dynamic hasAppInstanceId, appInstanceId;
@dynamic hasAppInstanceIdToken, appInstanceIdToken;
@dynamic requestedHiddenNamespaceArray, requestedHiddenNamespaceArray_Count;
@dynamic hasSdkVersion, sdkVersion;
@dynamic analyticsUserPropertyArray, analyticsUserPropertyArray_Count;
@dynamic hasRequestedCacheExpirationSeconds, requestedCacheExpirationSeconds;
@dynamic hasFetchedConfigAgeSeconds, fetchedConfigAgeSeconds;
@dynamic hasActiveConfigAgeSeconds, activeConfigAgeSeconds;

typedef struct RCNPackageData__storage_ {
  uint32_t _has_storage_[1];
  int32_t versionCode;
  int32_t appVersionCode;
  int32_t sdkVersion;
  int32_t requestedCacheExpirationSeconds;
  int32_t fetchedConfigAgeSeconds;
  int32_t activeConfigAgeSeconds;
  NSString *packageName;
  NSData *digest;
  NSData *certHash;
  NSString *projectId;
  NSString *gmpProjectId;
  NSString *gamesProjectId;
  NSMutableArray *namespaceDigestArray;
  NSMutableArray *customVariableArray;
  NSData *appCertHash;
  NSString *appInstanceId;
  NSString *appVersion;
  NSString *appInstanceIdToken;
  NSMutableArray *requestedHiddenNamespaceArray;
  NSMutableArray *analyticsUserPropertyArray;
} RCNPackageData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "packageName",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_PackageName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, packageName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "versionCode",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_VersionCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, versionCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "digest",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_Digest,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, digest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "certHash",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_CertHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, certHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "projectId",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_ProjectId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, projectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gmpProjectId",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_GmpProjectId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, gmpProjectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gamesProjectId",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_GamesProjectId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, gamesProjectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "namespaceDigestArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RCNNamedValue),
        .number = RCNPackageData_FieldNumber_NamespaceDigestArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, namespaceDigestArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "customVariableArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RCNNamedValue),
        .number = RCNPackageData_FieldNumber_CustomVariableArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, customVariableArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appCertHash",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_AppCertHash,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, appCertHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "appVersionCode",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_AppVersionCode,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, appVersionCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "appInstanceId",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_AppInstanceId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, appInstanceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appVersion",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_AppVersion,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, appVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appInstanceIdToken",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_AppInstanceIdToken,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, appInstanceIdToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "requestedHiddenNamespaceArray",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_RequestedHiddenNamespaceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, requestedHiddenNamespaceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sdkVersion",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_SdkVersion,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, sdkVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "analyticsUserPropertyArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RCNNamedValue),
        .number = RCNPackageData_FieldNumber_AnalyticsUserPropertyArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, analyticsUserPropertyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "requestedCacheExpirationSeconds",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_RequestedCacheExpirationSeconds,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, requestedCacheExpirationSeconds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fetchedConfigAgeSeconds",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_FetchedConfigAgeSeconds,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, fetchedConfigAgeSeconds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "activeConfigAgeSeconds",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageData_FieldNumber_ActiveConfigAgeSeconds,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(RCNPackageData__storage_, activeConfigAgeSeconds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RCNPackageData class]
                                     rootClass:[RCNConfigRoot class]
                                          file:RCNConfigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RCNPackageData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RCNKeyValue

@implementation RCNKeyValue

@dynamic hasKey, key;
@dynamic hasValue, value;

typedef struct RCNKeyValue__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSData *value;
} RCNKeyValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = RCNKeyValue_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RCNKeyValue__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = RCNKeyValue_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RCNKeyValue__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RCNKeyValue class]
                                     rootClass:[RCNConfigRoot class]
                                          file:RCNConfigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RCNKeyValue__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RCNNamedValue

@implementation RCNNamedValue

@dynamic hasName, name;
@dynamic hasValue, value;

typedef struct RCNNamedValue__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *value;
} RCNNamedValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = RCNNamedValue_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RCNNamedValue__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = RCNNamedValue_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RCNNamedValue__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RCNNamedValue class]
                                     rootClass:[RCNConfigRoot class]
                                          file:RCNConfigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RCNNamedValue__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RCNConfigFetchRequest

@implementation RCNConfigFetchRequest

@dynamic hasConfig, config;
@dynamic hasAndroidId, androidId;
@dynamic packageDataArray, packageDataArray_Count;
@dynamic hasDeviceDataVersionInfo, deviceDataVersionInfo;
@dynamic hasSecurityToken, securityToken;
@dynamic hasClientVersion, clientVersion;
@dynamic hasGmsCoreVersion, gmsCoreVersion;
@dynamic hasApiLevel, apiLevel;
@dynamic hasDeviceCountry, deviceCountry;
@dynamic hasDeviceLocale, deviceLocale;
@dynamic hasDeviceType, deviceType;
@dynamic hasDeviceSubtype, deviceSubtype;
@dynamic hasOsVersion, osVersion;
@dynamic hasDeviceTimezoneId, deviceTimezoneId;

typedef struct RCNConfigFetchRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t clientVersion;
  int32_t gmsCoreVersion;
  int32_t apiLevel;
  int32_t deviceType;
  int32_t deviceSubtype;
  NSMutableArray *packageDataArray;
  NSString *deviceDataVersionInfo;
  AndroidConfigFetchProto *config;
  NSString *deviceCountry;
  NSString *deviceLocale;
  NSString *osVersion;
  NSString *deviceTimezoneId;
  uint64_t androidId;
  uint64_t securityToken;
} RCNConfigFetchRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "androidId",
        .dataTypeSpecific.className = NULL,
        .number = RCNConfigFetchRequest_FieldNumber_AndroidId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RCNConfigFetchRequest__storage_, androidId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "packageDataArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RCNPackageData),
        .number = RCNConfigFetchRequest_FieldNumber_PackageDataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RCNConfigFetchRequest__storage_, packageDataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deviceDataVersionInfo",
        .dataTypeSpecific.className = NULL,
        .number = RCNConfigFetchRequest_FieldNumber_DeviceDataVersionInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RCNConfigFetchRequest__storage_, deviceDataVersionInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "securityToken",
        .dataTypeSpecific.className = NULL,
        .number = RCNConfigFetchRequest_FieldNumber_SecurityToken,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RCNConfigFetchRequest__storage_, securityToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "config",
        .dataTypeSpecific.className = GPBStringifySymbol(AndroidConfigFetchProto),
        .number = RCNConfigFetchRequest_FieldNumber_Config,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RCNConfigFetchRequest__storage_, config),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.className = NULL,
        .number = RCNConfigFetchRequest_FieldNumber_ClientVersion,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RCNConfigFetchRequest__storage_, clientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gmsCoreVersion",
        .dataTypeSpecific.className = NULL,
        .number = RCNConfigFetchRequest_FieldNumber_GmsCoreVersion,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RCNConfigFetchRequest__storage_, gmsCoreVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "apiLevel",
        .dataTypeSpecific.className = NULL,
        .number = RCNConfigFetchRequest_FieldNumber_ApiLevel,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RCNConfigFetchRequest__storage_, apiLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceCountry",
        .dataTypeSpecific.className = NULL,
        .number = RCNConfigFetchRequest_FieldNumber_DeviceCountry,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RCNConfigFetchRequest__storage_, deviceCountry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceLocale",
        .dataTypeSpecific.className = NULL,
        .number = RCNConfigFetchRequest_FieldNumber_DeviceLocale,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RCNConfigFetchRequest__storage_, deviceLocale),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = RCNConfigFetchRequest_FieldNumber_DeviceType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RCNConfigFetchRequest__storage_, deviceType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceSubtype",
        .dataTypeSpecific.className = NULL,
        .number = RCNConfigFetchRequest_FieldNumber_DeviceSubtype,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(RCNConfigFetchRequest__storage_, deviceSubtype),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "osVersion",
        .dataTypeSpecific.className = NULL,
        .number = RCNConfigFetchRequest_FieldNumber_OsVersion,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(RCNConfigFetchRequest__storage_, osVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceTimezoneId",
        .dataTypeSpecific.className = NULL,
        .number = RCNConfigFetchRequest_FieldNumber_DeviceTimezoneId,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(RCNConfigFetchRequest__storage_, deviceTimezoneId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RCNConfigFetchRequest class]
                                     rootClass:[RCNConfigRoot class]
                                          file:RCNConfigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RCNConfigFetchRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RCNPackageTable

@implementation RCNPackageTable

@dynamic hasPackageName, packageName;
@dynamic entryArray, entryArray_Count;
@dynamic hasProjectId, projectId;

typedef struct RCNPackageTable__storage_ {
  uint32_t _has_storage_[1];
  NSString *packageName;
  NSMutableArray *entryArray;
  NSString *projectId;
} RCNPackageTable__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "packageName",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageTable_FieldNumber_PackageName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RCNPackageTable__storage_, packageName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "entryArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RCNKeyValue),
        .number = RCNPackageTable_FieldNumber_EntryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RCNPackageTable__storage_, entryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "projectId",
        .dataTypeSpecific.className = NULL,
        .number = RCNPackageTable_FieldNumber_ProjectId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RCNPackageTable__storage_, projectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RCNPackageTable class]
                                     rootClass:[RCNConfigRoot class]
                                          file:RCNConfigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RCNPackageTable__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RCNAppNamespaceConfigTable

@implementation RCNAppNamespaceConfigTable

@dynamic hasNamespace_p, namespace_p;
@dynamic hasDigest, digest;
@dynamic entryArray, entryArray_Count;
@dynamic hasStatus, status;

typedef struct RCNAppNamespaceConfigTable__storage_ {
  uint32_t _has_storage_[1];
  RCNAppNamespaceConfigTable_NamespaceStatus status;
  NSString *namespace_p;
  NSString *digest;
  NSMutableArray *entryArray;
} RCNAppNamespaceConfigTable__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "namespace_p",
        .dataTypeSpecific.className = NULL,
        .number = RCNAppNamespaceConfigTable_FieldNumber_Namespace_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RCNAppNamespaceConfigTable__storage_, namespace_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "digest",
        .dataTypeSpecific.className = NULL,
        .number = RCNAppNamespaceConfigTable_FieldNumber_Digest,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RCNAppNamespaceConfigTable__storage_, digest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "entryArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RCNKeyValue),
        .number = RCNAppNamespaceConfigTable_FieldNumber_EntryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RCNAppNamespaceConfigTable__storage_, entryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = RCNAppNamespaceConfigTable_NamespaceStatus_EnumDescriptor,
        .number = RCNAppNamespaceConfigTable_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RCNAppNamespaceConfigTable__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RCNAppNamespaceConfigTable class]
                                     rootClass:[RCNConfigRoot class]
                                          file:RCNConfigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RCNAppNamespaceConfigTable__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum RCNAppNamespaceConfigTable_NamespaceStatus

GPBEnumDescriptor *RCNAppNamespaceConfigTable_NamespaceStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Update\000NoTemplate\000NoChange\000EmptyConfig\000N"
        "otAuthorized\000";
    static const int32_t values[] = {
        RCNAppNamespaceConfigTable_NamespaceStatus_Update,
        RCNAppNamespaceConfigTable_NamespaceStatus_NoTemplate,
        RCNAppNamespaceConfigTable_NamespaceStatus_NoChange,
        RCNAppNamespaceConfigTable_NamespaceStatus_EmptyConfig,
        RCNAppNamespaceConfigTable_NamespaceStatus_NotAuthorized,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RCNAppNamespaceConfigTable_NamespaceStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RCNAppNamespaceConfigTable_NamespaceStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RCNAppNamespaceConfigTable_NamespaceStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case RCNAppNamespaceConfigTable_NamespaceStatus_Update:
    case RCNAppNamespaceConfigTable_NamespaceStatus_NoTemplate:
    case RCNAppNamespaceConfigTable_NamespaceStatus_NoChange:
    case RCNAppNamespaceConfigTable_NamespaceStatus_EmptyConfig:
    case RCNAppNamespaceConfigTable_NamespaceStatus_NotAuthorized:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RCNAppConfigTable

@implementation RCNAppConfigTable

@dynamic hasAppName, appName;
@dynamic namespaceConfigArray, namespaceConfigArray_Count;
@dynamic experimentPayloadArray, experimentPayloadArray_Count;
@dynamic enabledFeatureKeysArray, enabledFeatureKeysArray_Count;

typedef struct RCNAppConfigTable__storage_ {
  uint32_t _has_storage_[1];
  NSString *appName;
  NSMutableArray *namespaceConfigArray;
  NSMutableArray *experimentPayloadArray;
  NSMutableArray *enabledFeatureKeysArray;
} RCNAppConfigTable__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "appName",
        .dataTypeSpecific.className = NULL,
        .number = RCNAppConfigTable_FieldNumber_AppName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RCNAppConfigTable__storage_, appName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "namespaceConfigArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RCNAppNamespaceConfigTable),
        .number = RCNAppConfigTable_FieldNumber_NamespaceConfigArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RCNAppConfigTable__storage_, namespaceConfigArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "experimentPayloadArray",
        .dataTypeSpecific.className = NULL,
        .number = RCNAppConfigTable_FieldNumber_ExperimentPayloadArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RCNAppConfigTable__storage_, experimentPayloadArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "enabledFeatureKeysArray",
        .dataTypeSpecific.className = NULL,
        .number = RCNAppConfigTable_FieldNumber_EnabledFeatureKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RCNAppConfigTable__storage_, enabledFeatureKeysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RCNAppConfigTable class]
                                     rootClass:[RCNConfigRoot class]
                                          file:RCNConfigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RCNAppConfigTable__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RCNConfigFetchResponse

@implementation RCNConfigFetchResponse

@dynamic packageTableArray, packageTableArray_Count;
@dynamic hasStatus, status;
@dynamic internalMetadataArray, internalMetadataArray_Count;
@dynamic appConfigArray, appConfigArray_Count;

typedef struct RCNConfigFetchResponse__storage_ {
  uint32_t _has_storage_[1];
  RCNConfigFetchResponse_ResponseStatus status;
  NSMutableArray *packageTableArray;
  NSMutableArray *internalMetadataArray;
  NSMutableArray *appConfigArray;
} RCNConfigFetchResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "packageTableArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RCNPackageTable),
        .number = RCNConfigFetchResponse_FieldNumber_PackageTableArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RCNConfigFetchResponse__storage_, packageTableArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = RCNConfigFetchResponse_ResponseStatus_EnumDescriptor,
        .number = RCNConfigFetchResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RCNConfigFetchResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "internalMetadataArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RCNKeyValue),
        .number = RCNConfigFetchResponse_FieldNumber_InternalMetadataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RCNConfigFetchResponse__storage_, internalMetadataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appConfigArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RCNAppConfigTable),
        .number = RCNConfigFetchResponse_FieldNumber_AppConfigArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RCNConfigFetchResponse__storage_, appConfigArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RCNConfigFetchResponse class]
                                     rootClass:[RCNConfigRoot class]
                                          file:RCNConfigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RCNConfigFetchResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum RCNConfigFetchResponse_ResponseStatus

GPBEnumDescriptor *RCNConfigFetchResponse_ResponseStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Success\000NoPackagesInRequest\000";
    static const int32_t values[] = {
        RCNConfigFetchResponse_ResponseStatus_Success,
        RCNConfigFetchResponse_ResponseStatus_NoPackagesInRequest,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RCNConfigFetchResponse_ResponseStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RCNConfigFetchResponse_ResponseStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RCNConfigFetchResponse_ResponseStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case RCNConfigFetchResponse_ResponseStatus_Success:
    case RCNConfigFetchResponse_ResponseStatus_NoPackagesInRequest:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
