// Copyright 2019 Google
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: developers/mobile/abt/proto/experiment_payload.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "FirebaseABTesting/Sources/Protos/developers/mobile/abt/proto/ExperimentPayload.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ABTExperimentPayloadRoot

@implementation ABTExperimentPayloadRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ABTExperimentPayloadRoot_FileDescriptor

static GPBFileDescriptor *ABTExperimentPayloadRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"developers.mobile.abt"
                                                 objcPrefix:@"ABT"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - ABTExperimentLite

@implementation ABTExperimentLite

@dynamic experimentId;

typedef struct ABTExperimentLite__storage_ {
  uint32_t _has_storage_[1];
  NSString *experimentId;
} ABTExperimentLite__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "experimentId",
        .dataTypeSpecific.className = NULL,
        .number = ABTExperimentLite_FieldNumber_ExperimentId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ABTExperimentLite__storage_, experimentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ABTExperimentLite class]
                                     rootClass:[ABTExperimentPayloadRoot class]
                                          file:ABTExperimentPayloadRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ABTExperimentLite__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ABTExperimentPayload

@implementation ABTExperimentPayload

@dynamic experimentId;
@dynamic variantId;
@dynamic experimentStartTimeMillis;
@dynamic triggerEvent;
@dynamic triggerTimeoutMillis;
@dynamic timeToLiveMillis;
@dynamic setEventToLog;
@dynamic activateEventToLog;
@dynamic clearEventToLog;
@dynamic timeoutEventToLog;
@dynamic ttlExpiryEventToLog;
@dynamic overflowPolicy;
@dynamic ongoingExperimentsArray, ongoingExperimentsArray_Count;

typedef struct ABTExperimentPayload__storage_ {
  uint32_t _has_storage_[1];
  ABTExperimentPayload_ExperimentOverflowPolicy overflowPolicy;
  NSString *experimentId;
  NSString *variantId;
  NSString *triggerEvent;
  NSString *setEventToLog;
  NSString *activateEventToLog;
  NSString *clearEventToLog;
  NSString *timeoutEventToLog;
  NSString *ttlExpiryEventToLog;
  NSMutableArray *ongoingExperimentsArray;
  int64_t experimentStartTimeMillis;
  int64_t triggerTimeoutMillis;
  int64_t timeToLiveMillis;
} ABTExperimentPayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "experimentId",
        .dataTypeSpecific.className = NULL,
        .number = ABTExperimentPayload_FieldNumber_ExperimentId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ABTExperimentPayload__storage_, experimentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "variantId",
        .dataTypeSpecific.className = NULL,
        .number = ABTExperimentPayload_FieldNumber_VariantId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ABTExperimentPayload__storage_, variantId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "experimentStartTimeMillis",
        .dataTypeSpecific.className = NULL,
        .number = ABTExperimentPayload_FieldNumber_ExperimentStartTimeMillis,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ABTExperimentPayload__storage_, experimentStartTimeMillis),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "triggerEvent",
        .dataTypeSpecific.className = NULL,
        .number = ABTExperimentPayload_FieldNumber_TriggerEvent,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ABTExperimentPayload__storage_, triggerEvent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "triggerTimeoutMillis",
        .dataTypeSpecific.className = NULL,
        .number = ABTExperimentPayload_FieldNumber_TriggerTimeoutMillis,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ABTExperimentPayload__storage_, triggerTimeoutMillis),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timeToLiveMillis",
        .dataTypeSpecific.className = NULL,
        .number = ABTExperimentPayload_FieldNumber_TimeToLiveMillis,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ABTExperimentPayload__storage_, timeToLiveMillis),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "setEventToLog",
        .dataTypeSpecific.className = NULL,
        .number = ABTExperimentPayload_FieldNumber_SetEventToLog,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ABTExperimentPayload__storage_, setEventToLog),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "activateEventToLog",
        .dataTypeSpecific.className = NULL,
        .number = ABTExperimentPayload_FieldNumber_ActivateEventToLog,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ABTExperimentPayload__storage_, activateEventToLog),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clearEventToLog",
        .dataTypeSpecific.className = NULL,
        .number = ABTExperimentPayload_FieldNumber_ClearEventToLog,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ABTExperimentPayload__storage_, clearEventToLog),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeoutEventToLog",
        .dataTypeSpecific.className = NULL,
        .number = ABTExperimentPayload_FieldNumber_TimeoutEventToLog,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ABTExperimentPayload__storage_, timeoutEventToLog),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ttlExpiryEventToLog",
        .dataTypeSpecific.className = NULL,
        .number = ABTExperimentPayload_FieldNumber_TtlExpiryEventToLog,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ABTExperimentPayload__storage_, ttlExpiryEventToLog),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "overflowPolicy",
        .dataTypeSpecific.enumDescFunc = ABTExperimentPayload_ExperimentOverflowPolicy_EnumDescriptor,
        .number = ABTExperimentPayload_FieldNumber_OverflowPolicy,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ABTExperimentPayload__storage_, overflowPolicy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "ongoingExperimentsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ABTExperimentLite),
        .number = ABTExperimentPayload_FieldNumber_OngoingExperimentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ABTExperimentPayload__storage_, ongoingExperimentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ABTExperimentPayload class]
                                     rootClass:[ABTExperimentPayloadRoot class]
                                          file:ABTExperimentPayloadRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ABTExperimentPayload__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ABTExperimentPayload_OverflowPolicy_RawValue(ABTExperimentPayload *message) {
  GPBDescriptor *descriptor = [ABTExperimentPayload descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ABTExperimentPayload_FieldNumber_OverflowPolicy];
  return GPBGetMessageInt32Field(message, field);
}

void SetABTExperimentPayload_OverflowPolicy_RawValue(ABTExperimentPayload *message, int32_t value) {
  GPBDescriptor *descriptor = [ABTExperimentPayload descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ABTExperimentPayload_FieldNumber_OverflowPolicy];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ABTExperimentPayload_ExperimentOverflowPolicy

GPBEnumDescriptor *ABTExperimentPayload_ExperimentOverflowPolicy_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "PolicyUnspecified\000DiscardOldest\000IgnoreNe"
        "west\000";
    static const int32_t values[] = {
        ABTExperimentPayload_ExperimentOverflowPolicy_PolicyUnspecified,
        ABTExperimentPayload_ExperimentOverflowPolicy_DiscardOldest,
        ABTExperimentPayload_ExperimentOverflowPolicy_IgnoreNewest,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ABTExperimentPayload_ExperimentOverflowPolicy)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ABTExperimentPayload_ExperimentOverflowPolicy_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ABTExperimentPayload_ExperimentOverflowPolicy_IsValidValue(int32_t value__) {
  switch (value__) {
    case ABTExperimentPayload_ExperimentOverflowPolicy_PolicyUnspecified:
    case ABTExperimentPayload_ExperimentOverflowPolicy_DiscardOldest:
    case ABTExperimentPayload_ExperimentOverflowPolicy_IgnoreNewest:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
