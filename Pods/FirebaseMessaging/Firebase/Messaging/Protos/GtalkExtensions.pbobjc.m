/*
 * Copyright 2017 Google
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: buzz/mobile/proto/gtalk_extensions.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "GtalkExtensions.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - GtalkGtalkExtensionsRoot

@implementation GtalkGtalkExtensionsRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - GtalkGtalkExtensionsRoot_FileDescriptor

static GPBFileDescriptor *GtalkGtalkExtensionsRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"mobilegtalk"
                                                 objcPrefix:@"Gtalk"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - GtalkRosterQuery

@implementation GtalkRosterQuery

@dynamic hasEtag, etag;
@dynamic hasNotModified, notModified;
@dynamic itemArray, itemArray_Count;
@dynamic hasAvatarWidth, avatarWidth;
@dynamic hasAvatarHeight, avatarHeight;

typedef struct GtalkRosterQuery__storage_ {
  uint32_t _has_storage_[1];
  int32_t avatarWidth;
  int32_t avatarHeight;
  NSString *etag;
  NSMutableArray *itemArray;
} GtalkRosterQuery__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "etag",
        .dataTypeSpecific.className = NULL,
        .number = GtalkRosterQuery_FieldNumber_Etag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkRosterQuery__storage_, etag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "notModified",
        .dataTypeSpecific.className = NULL,
        .number = GtalkRosterQuery_FieldNumber_NotModified,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkRosterItem),
        .number = GtalkRosterQuery_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GtalkRosterQuery__storage_, itemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "avatarWidth",
        .dataTypeSpecific.className = NULL,
        .number = GtalkRosterQuery_FieldNumber_AvatarWidth,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkRosterQuery__storage_, avatarWidth),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "avatarHeight",
        .dataTypeSpecific.className = NULL,
        .number = GtalkRosterQuery_FieldNumber_AvatarHeight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GtalkRosterQuery__storage_, avatarHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkRosterQuery class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkRosterQuery__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\013\000\005\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkRosterItem

@implementation GtalkRosterItem

@dynamic hasJid, jid;
@dynamic hasName, name;
@dynamic hasSubscription, subscription;
@dynamic hasAsk, ask;
@dynamic groupArray, groupArray_Count;
@dynamic hasQuickContact, quickContact;
@dynamic hasDisplay, display;
@dynamic hasRejected, rejected;

typedef struct GtalkRosterItem__storage_ {
  uint32_t _has_storage_[1];
  GtalkRosterItem_SubscriptionType subscription;
  GtalkRosterItem_AskType ask;
  GtalkRosterItem_DisplayType display;
  NSString *jid;
  NSString *name;
  NSMutableArray *groupArray;
} GtalkRosterItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "jid",
        .dataTypeSpecific.className = NULL,
        .number = GtalkRosterItem_FieldNumber_Jid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkRosterItem__storage_, jid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GtalkRosterItem_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkRosterItem__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subscription",
        .dataTypeSpecific.enumDescFunc = GtalkRosterItem_SubscriptionType_EnumDescriptor,
        .number = GtalkRosterItem_FieldNumber_Subscription,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkRosterItem__storage_, subscription),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "ask",
        .dataTypeSpecific.enumDescFunc = GtalkRosterItem_AskType_EnumDescriptor,
        .number = GtalkRosterItem_FieldNumber_Ask,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkRosterItem__storage_, ask),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "groupArray",
        .dataTypeSpecific.className = NULL,
        .number = GtalkRosterItem_FieldNumber_GroupArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GtalkRosterItem__storage_, groupArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "quickContact",
        .dataTypeSpecific.className = NULL,
        .number = GtalkRosterItem_FieldNumber_QuickContact,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "display",
        .dataTypeSpecific.enumDescFunc = GtalkRosterItem_DisplayType_EnumDescriptor,
        .number = GtalkRosterItem_FieldNumber_Display,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GtalkRosterItem__storage_, display),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "rejected",
        .dataTypeSpecific.className = NULL,
        .number = GtalkRosterItem_FieldNumber_Rejected,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkRosterItem class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkRosterItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum GtalkRosterItem_SubscriptionType

GPBEnumDescriptor *GtalkRosterItem_SubscriptionType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000To\000From\000Both\000Remove\000";
    static const int32_t values[] = {
        GtalkRosterItem_SubscriptionType_None,
        GtalkRosterItem_SubscriptionType_To,
        GtalkRosterItem_SubscriptionType_From,
        GtalkRosterItem_SubscriptionType_Both,
        GtalkRosterItem_SubscriptionType_Remove,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GtalkRosterItem_SubscriptionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GtalkRosterItem_SubscriptionType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GtalkRosterItem_SubscriptionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GtalkRosterItem_SubscriptionType_None:
    case GtalkRosterItem_SubscriptionType_To:
    case GtalkRosterItem_SubscriptionType_From:
    case GtalkRosterItem_SubscriptionType_Both:
    case GtalkRosterItem_SubscriptionType_Remove:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GtalkRosterItem_AskType

GPBEnumDescriptor *GtalkRosterItem_AskType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Subscribe\000";
    static const int32_t values[] = {
        GtalkRosterItem_AskType_Subscribe,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GtalkRosterItem_AskType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GtalkRosterItem_AskType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GtalkRosterItem_AskType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GtalkRosterItem_AskType_Subscribe:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GtalkRosterItem_DisplayType

GPBEnumDescriptor *GtalkRosterItem_DisplayType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Blocked\000Hidden\000Pinned\000";
    static const int32_t values[] = {
        GtalkRosterItem_DisplayType_Blocked,
        GtalkRosterItem_DisplayType_Hidden,
        GtalkRosterItem_DisplayType_Pinned,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GtalkRosterItem_DisplayType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GtalkRosterItem_DisplayType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GtalkRosterItem_DisplayType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GtalkRosterItem_DisplayType_Blocked:
    case GtalkRosterItem_DisplayType_Hidden:
    case GtalkRosterItem_DisplayType_Pinned:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GtalkRmqLastId

@implementation GtalkRmqLastId

@dynamic hasId_p, id_p;

typedef struct GtalkRmqLastId__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} GtalkRmqLastId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GtalkRmqLastId_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkRmqLastId__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkRmqLastId class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkRmqLastId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkRmqAck

@implementation GtalkRmqAck

@dynamic hasId_p, id_p;

typedef struct GtalkRmqAck__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} GtalkRmqAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GtalkRmqAck_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkRmqAck__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkRmqAck class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkRmqAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkVCard

@implementation GtalkVCard

@dynamic hasVersion, version;
@dynamic hasFullName, fullName;
@dynamic hasPhoto, photo;
@dynamic hasAvatarHash, avatarHash;
@dynamic hasModified, modified;

typedef struct GtalkVCard__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
  NSString *fullName;
  GtalkPhoto *photo;
  NSString *avatarHash;
} GtalkVCard__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = GtalkVCard_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkVCard__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fullName",
        .dataTypeSpecific.className = NULL,
        .number = GtalkVCard_FieldNumber_FullName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkVCard__storage_, fullName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "photo",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkPhoto),
        .number = GtalkVCard_FieldNumber_Photo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkVCard__storage_, photo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "avatarHash",
        .dataTypeSpecific.className = NULL,
        .number = GtalkVCard_FieldNumber_AvatarHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkVCard__storage_, avatarHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "modified",
        .dataTypeSpecific.className = NULL,
        .number = GtalkVCard_FieldNumber_Modified,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkVCard class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkVCard__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkPhoto

@implementation GtalkPhoto

@dynamic hasType, type;
@dynamic hasData_p, data_p;

typedef struct GtalkPhoto__storage_ {
  uint32_t _has_storage_[1];
  NSString *type;
  NSString *data_p;
} GtalkPhoto__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPhoto_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkPhoto__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPhoto_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkPhoto__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkPhoto class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkPhoto__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkChatRead

@implementation GtalkChatRead

@dynamic hasUser, user;

typedef struct GtalkChatRead__storage_ {
  uint32_t _has_storage_[1];
  NSString *user;
} GtalkChatRead__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "user",
        .dataTypeSpecific.className = NULL,
        .number = GtalkChatRead_FieldNumber_User,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkChatRead__storage_, user),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkChatRead class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkChatRead__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkChatClosed

@implementation GtalkChatClosed

@dynamic hasUser, user;

typedef struct GtalkChatClosed__storage_ {
  uint32_t _has_storage_[1];
  NSString *user;
} GtalkChatClosed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "user",
        .dataTypeSpecific.className = NULL,
        .number = GtalkChatClosed_FieldNumber_User,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkChatClosed__storage_, user),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkChatClosed class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkChatClosed__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkCapabilities

@implementation GtalkCapabilities

@dynamic hasNode, node;
@dynamic hasVer, ver;
@dynamic hasExt, ext;
@dynamic hasHash_p, hash_p;

typedef struct GtalkCapabilities__storage_ {
  uint32_t _has_storage_[1];
  NSString *node;
  NSString *ver;
  NSString *ext;
  NSString *hash_p;
} GtalkCapabilities__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "node",
        .dataTypeSpecific.className = NULL,
        .number = GtalkCapabilities_FieldNumber_Node,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkCapabilities__storage_, node),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ver",
        .dataTypeSpecific.className = NULL,
        .number = GtalkCapabilities_FieldNumber_Ver,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkCapabilities__storage_, ver),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ext",
        .dataTypeSpecific.className = NULL,
        .number = GtalkCapabilities_FieldNumber_Ext,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkCapabilities__storage_, ext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = GtalkCapabilities_FieldNumber_Hash_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkCapabilities__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkCapabilities class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkCapabilities__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkSharedStatus

@implementation GtalkSharedStatus

@dynamic hasStatusMax, statusMax;
@dynamic hasStatusListMax, statusListMax;
@dynamic hasStatusListContentsMax, statusListContentsMax;
@dynamic hasStatus, status;
@dynamic hasShow, show;
@dynamic statusListArray, statusListArray_Count;
@dynamic hasInvisible, invisible;
@dynamic hasStatusMinVersion, statusMinVersion;

typedef struct GtalkSharedStatus__storage_ {
  uint32_t _has_storage_[1];
  int32_t statusMax;
  int32_t statusListMax;
  int32_t statusListContentsMax;
  GtalkSharedStatus_ShowType show;
  int32_t statusMinVersion;
  NSString *status;
  NSMutableArray *statusListArray;
} GtalkSharedStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusMax",
        .dataTypeSpecific.className = NULL,
        .number = GtalkSharedStatus_FieldNumber_StatusMax,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkSharedStatus__storage_, statusMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "statusListMax",
        .dataTypeSpecific.className = NULL,
        .number = GtalkSharedStatus_FieldNumber_StatusListMax,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkSharedStatus__storage_, statusListMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "statusListContentsMax",
        .dataTypeSpecific.className = NULL,
        .number = GtalkSharedStatus_FieldNumber_StatusListContentsMax,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkSharedStatus__storage_, statusListContentsMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = GtalkSharedStatus_FieldNumber_Status,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkSharedStatus__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "show",
        .dataTypeSpecific.enumDescFunc = GtalkSharedStatus_ShowType_EnumDescriptor,
        .number = GtalkSharedStatus_FieldNumber_Show,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GtalkSharedStatus__storage_, show),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "statusListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkSharedStatus_StatusList),
        .number = GtalkSharedStatus_FieldNumber_StatusListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GtalkSharedStatus__storage_, statusListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeGroup,
      },
      {
        .name = "invisible",
        .dataTypeSpecific.className = NULL,
        .number = GtalkSharedStatus_FieldNumber_Invisible,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "statusMinVersion",
        .dataTypeSpecific.className = NULL,
        .number = GtalkSharedStatus_FieldNumber_StatusMinVersion,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GtalkSharedStatus__storage_, statusMinVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkSharedStatus class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkSharedStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum GtalkSharedStatus_ShowType

GPBEnumDescriptor *GtalkSharedStatus_ShowType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Default\000Dnd\000";
    static const int32_t values[] = {
        GtalkSharedStatus_ShowType_Default,
        GtalkSharedStatus_ShowType_Dnd,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GtalkSharedStatus_ShowType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GtalkSharedStatus_ShowType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GtalkSharedStatus_ShowType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GtalkSharedStatus_ShowType_Default:
    case GtalkSharedStatus_ShowType_Dnd:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GtalkSharedStatus_StatusList

@implementation GtalkSharedStatus_StatusList

@dynamic hasShow, show;
@dynamic statusArray, statusArray_Count;

typedef struct GtalkSharedStatus_StatusList__storage_ {
  uint32_t _has_storage_[1];
  GtalkSharedStatus_ShowType show;
  NSMutableArray *statusArray;
} GtalkSharedStatus_StatusList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "show",
        .dataTypeSpecific.enumDescFunc = GtalkSharedStatus_ShowType_EnumDescriptor,
        .number = GtalkSharedStatus_StatusList_FieldNumber_Show,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkSharedStatus_StatusList__storage_, show),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "statusArray",
        .dataTypeSpecific.className = NULL,
        .number = GtalkSharedStatus_StatusList_FieldNumber_StatusArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GtalkSharedStatus_StatusList__storage_, statusArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkSharedStatus_StatusList class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkSharedStatus_StatusList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GtalkSharedStatus)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkOtrQuery

@implementation GtalkOtrQuery

@dynamic hasNosaveDefault, nosaveDefault;
@dynamic itemArray, itemArray_Count;
@dynamic hasEtag, etag;
@dynamic hasNotModified, notModified;

typedef struct GtalkOtrQuery__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemArray;
  NSString *etag;
} GtalkOtrQuery__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nosaveDefault",
        .dataTypeSpecific.className = NULL,
        .number = GtalkOtrQuery_FieldNumber_NosaveDefault,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkOtrItem),
        .number = GtalkOtrQuery_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GtalkOtrQuery__storage_, itemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "etag",
        .dataTypeSpecific.className = NULL,
        .number = GtalkOtrQuery_FieldNumber_Etag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkOtrQuery__storage_, etag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "notModified",
        .dataTypeSpecific.className = NULL,
        .number = GtalkOtrQuery_FieldNumber_NotModified,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkOtrQuery class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkOtrQuery__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkOtrItem

@implementation GtalkOtrItem

@dynamic hasJid, jid;
@dynamic hasNosave, nosave;
@dynamic hasChangedByBuddy, changedByBuddy;

typedef struct GtalkOtrItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *jid;
} GtalkOtrItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "jid",
        .dataTypeSpecific.className = NULL,
        .number = GtalkOtrItem_FieldNumber_Jid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkOtrItem__storage_, jid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nosave",
        .dataTypeSpecific.className = NULL,
        .number = GtalkOtrItem_FieldNumber_Nosave,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "changedByBuddy",
        .dataTypeSpecific.className = NULL,
        .number = GtalkOtrItem_FieldNumber_ChangedByBuddy,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkOtrItem class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkOtrItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkIdle

@implementation GtalkIdle

@dynamic hasIdle, idle;
@dynamic hasAway, away;

typedef struct GtalkIdle__storage_ {
  uint32_t _has_storage_[1];
} GtalkIdle__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idle",
        .dataTypeSpecific.className = NULL,
        .number = GtalkIdle_FieldNumber_Idle,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "away",
        .dataTypeSpecific.className = NULL,
        .number = GtalkIdle_FieldNumber_Away,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkIdle class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkIdle__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkPostAuthBatchQuery

@implementation GtalkPostAuthBatchQuery

@dynamic hasAvailable, available;
@dynamic hasDeviceIdle, deviceIdle;
@dynamic hasMobileIndicator, mobileIndicator;
@dynamic hasSharedStatusVersion, sharedStatusVersion;
@dynamic hasRosterEtag, rosterEtag;
@dynamic hasOtrEtag, otrEtag;
@dynamic hasAvatarHash, avatarHash;
@dynamic hasVcardQueryStanzaId, vcardQueryStanzaId;
@dynamic hasCapabilitiesExtFlags, capabilitiesExtFlags;

typedef struct GtalkPostAuthBatchQuery__storage_ {
  uint32_t _has_storage_[1];
  int32_t sharedStatusVersion;
  int32_t capabilitiesExtFlags;
  NSString *rosterEtag;
  NSString *otrEtag;
  NSString *avatarHash;
  NSString *vcardQueryStanzaId;
} GtalkPostAuthBatchQuery__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "available",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPostAuthBatchQuery_FieldNumber_Available,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "deviceIdle",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPostAuthBatchQuery_FieldNumber_DeviceIdle,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "mobileIndicator",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPostAuthBatchQuery_FieldNumber_MobileIndicator,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sharedStatusVersion",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPostAuthBatchQuery_FieldNumber_SharedStatusVersion,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GtalkPostAuthBatchQuery__storage_, sharedStatusVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "rosterEtag",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPostAuthBatchQuery_FieldNumber_RosterEtag,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GtalkPostAuthBatchQuery__storage_, rosterEtag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "otrEtag",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPostAuthBatchQuery_FieldNumber_OtrEtag,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GtalkPostAuthBatchQuery__storage_, otrEtag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatarHash",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPostAuthBatchQuery_FieldNumber_AvatarHash,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(GtalkPostAuthBatchQuery__storage_, avatarHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "vcardQueryStanzaId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPostAuthBatchQuery_FieldNumber_VcardQueryStanzaId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(GtalkPostAuthBatchQuery__storage_, vcardQueryStanzaId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "capabilitiesExtFlags",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPostAuthBatchQuery_FieldNumber_CapabilitiesExtFlags,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(GtalkPostAuthBatchQuery__storage_, capabilitiesExtFlags),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkPostAuthBatchQuery class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkPostAuthBatchQuery__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum GtalkPostAuthBatchQuery_CapabilitiesExtFlags

GPBEnumDescriptor *GtalkPostAuthBatchQuery_CapabilitiesExtFlags_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "HasVoiceV1\000HasVideoV1\000HasCameraV1\000HasPmu"
        "cV1\000";
    static const int32_t values[] = {
        GtalkPostAuthBatchQuery_CapabilitiesExtFlags_HasVoiceV1,
        GtalkPostAuthBatchQuery_CapabilitiesExtFlags_HasVideoV1,
        GtalkPostAuthBatchQuery_CapabilitiesExtFlags_HasCameraV1,
        GtalkPostAuthBatchQuery_CapabilitiesExtFlags_HasPmucV1,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GtalkPostAuthBatchQuery_CapabilitiesExtFlags)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GtalkPostAuthBatchQuery_CapabilitiesExtFlags_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GtalkPostAuthBatchQuery_CapabilitiesExtFlags_IsValidValue(int32_t value__) {
  switch (value__) {
    case GtalkPostAuthBatchQuery_CapabilitiesExtFlags_HasVoiceV1:
    case GtalkPostAuthBatchQuery_CapabilitiesExtFlags_HasVideoV1:
    case GtalkPostAuthBatchQuery_CapabilitiesExtFlags_HasCameraV1:
    case GtalkPostAuthBatchQuery_CapabilitiesExtFlags_HasPmucV1:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GtalkStreamAck

@implementation GtalkStreamAck


typedef struct GtalkStreamAck__storage_ {
  uint32_t _has_storage_[1];
} GtalkStreamAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkStreamAck class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GtalkStreamAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkSelectiveAck

@implementation GtalkSelectiveAck

@dynamic idArray, idArray_Count;

typedef struct GtalkSelectiveAck__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *idArray;
} GtalkSelectiveAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idArray",
        .dataTypeSpecific.className = NULL,
        .number = GtalkSelectiveAck_FieldNumber_IdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GtalkSelectiveAck__storage_, idArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkSelectiveAck class]
                                     rootClass:[GtalkGtalkExtensionsRoot class]
                                          file:GtalkGtalkExtensionsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkSelectiveAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
