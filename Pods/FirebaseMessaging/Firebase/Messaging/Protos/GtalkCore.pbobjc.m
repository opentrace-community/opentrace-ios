/*
 * Copyright 2017 Google
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: buzz/mobile/proto/gtalk_core.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "GtalkCore.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - GtalkGtalkCoreRoot

@implementation GtalkGtalkCoreRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - GtalkGtalkCoreRoot_FileDescriptor

static GPBFileDescriptor *GtalkGtalkCoreRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"mobilegtalk"
                                                 objcPrefix:@"Gtalk"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - GtalkHeartbeatPing

@implementation GtalkHeartbeatPing

@dynamic hasStreamId, streamId;
@dynamic hasLastStreamIdReceived, lastStreamIdReceived;
@dynamic hasStatus, status;
@dynamic hasCellTower, cellTower;
@dynamic hasIntervalMs, intervalMs;

typedef struct GtalkHeartbeatPing__storage_ {
  uint32_t _has_storage_[1];
  int32_t streamId;
  int32_t lastStreamIdReceived;
  int32_t intervalMs;
  GtalkCellTower *cellTower;
  int64_t status;
} GtalkHeartbeatPing__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "streamId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkHeartbeatPing_FieldNumber_StreamId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkHeartbeatPing__storage_, streamId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastStreamIdReceived",
        .dataTypeSpecific.className = NULL,
        .number = GtalkHeartbeatPing_FieldNumber_LastStreamIdReceived,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkHeartbeatPing__storage_, lastStreamIdReceived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = GtalkHeartbeatPing_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkHeartbeatPing__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cellTower",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkCellTower),
        .number = GtalkHeartbeatPing_FieldNumber_CellTower,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkHeartbeatPing__storage_, cellTower),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "intervalMs",
        .dataTypeSpecific.className = NULL,
        .number = GtalkHeartbeatPing_FieldNumber_IntervalMs,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GtalkHeartbeatPing__storage_, intervalMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkHeartbeatPing class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkHeartbeatPing__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkHeartbeatAck

@implementation GtalkHeartbeatAck

@dynamic hasStreamId, streamId;
@dynamic hasLastStreamIdReceived, lastStreamIdReceived;
@dynamic hasStatus, status;
@dynamic hasCellTower, cellTower;
@dynamic hasIntervalMs, intervalMs;

typedef struct GtalkHeartbeatAck__storage_ {
  uint32_t _has_storage_[1];
  int32_t streamId;
  int32_t lastStreamIdReceived;
  int32_t intervalMs;
  GtalkCellTower *cellTower;
  int64_t status;
} GtalkHeartbeatAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "streamId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkHeartbeatAck_FieldNumber_StreamId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkHeartbeatAck__storage_, streamId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastStreamIdReceived",
        .dataTypeSpecific.className = NULL,
        .number = GtalkHeartbeatAck_FieldNumber_LastStreamIdReceived,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkHeartbeatAck__storage_, lastStreamIdReceived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = GtalkHeartbeatAck_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkHeartbeatAck__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cellTower",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkCellTower),
        .number = GtalkHeartbeatAck_FieldNumber_CellTower,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkHeartbeatAck__storage_, cellTower),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "intervalMs",
        .dataTypeSpecific.className = NULL,
        .number = GtalkHeartbeatAck_FieldNumber_IntervalMs,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GtalkHeartbeatAck__storage_, intervalMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkHeartbeatAck class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkHeartbeatAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkErrorInfo

@implementation GtalkErrorInfo

@dynamic hasCode, code;
@dynamic hasMessage, message;
@dynamic hasType, type;
@dynamic hasExtension, extension;

typedef struct GtalkErrorInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  NSString *message;
  NSString *type;
  GtalkExtension *extension;
} GtalkErrorInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = GtalkErrorInfo_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkErrorInfo__storage_, code),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = GtalkErrorInfo_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkErrorInfo__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = GtalkErrorInfo_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkErrorInfo__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extension",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkExtension),
        .number = GtalkErrorInfo_FieldNumber_Extension,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkErrorInfo__storage_, extension),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkErrorInfo class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkErrorInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkSetting

@implementation GtalkSetting

@dynamic hasName, name;
@dynamic hasValue, value;

typedef struct GtalkSetting__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *value;
} GtalkSetting__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GtalkSetting_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkSetting__storage_, name),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = GtalkSetting_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkSetting__storage_, value),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkSetting class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkSetting__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkHeartbeatStat

@implementation GtalkHeartbeatStat

@dynamic hasIp, ip;
@dynamic hasTimeout, timeout;
@dynamic hasIntervalMs, intervalMs;

typedef struct GtalkHeartbeatStat__storage_ {
  uint32_t _has_storage_[1];
  int32_t intervalMs;
  NSString *ip;
} GtalkHeartbeatStat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = GtalkHeartbeatStat_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkHeartbeatStat__storage_, ip),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeout",
        .dataTypeSpecific.className = NULL,
        .number = GtalkHeartbeatStat_FieldNumber_Timeout,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "intervalMs",
        .dataTypeSpecific.className = NULL,
        .number = GtalkHeartbeatStat_FieldNumber_IntervalMs,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkHeartbeatStat__storage_, intervalMs),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkHeartbeatStat class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkHeartbeatStat__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkHeartbeatConfig

@implementation GtalkHeartbeatConfig

@dynamic hasUploadStat, uploadStat;
@dynamic hasIp, ip;
@dynamic hasIntervalMs, intervalMs;

typedef struct GtalkHeartbeatConfig__storage_ {
  uint32_t _has_storage_[1];
  int32_t intervalMs;
  NSString *ip;
} GtalkHeartbeatConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uploadStat",
        .dataTypeSpecific.className = NULL,
        .number = GtalkHeartbeatConfig_FieldNumber_UploadStat,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = GtalkHeartbeatConfig_FieldNumber_Ip,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkHeartbeatConfig__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "intervalMs",
        .dataTypeSpecific.className = NULL,
        .number = GtalkHeartbeatConfig_FieldNumber_IntervalMs,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkHeartbeatConfig__storage_, intervalMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkHeartbeatConfig class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkHeartbeatConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkLoginRequest

@implementation GtalkLoginRequest

@dynamic hasId_p, id_p;
@dynamic hasDomain, domain;
@dynamic hasUser, user;
@dynamic hasResource, resource;
@dynamic hasAuthToken, authToken;
@dynamic hasDeviceId, deviceId;
@dynamic hasLastRmqId, lastRmqId;
@dynamic settingArray, settingArray_Count;
@dynamic receivedPersistentIdArray, receivedPersistentIdArray_Count;
@dynamic hasIncludeStreamIds, includeStreamIds;
@dynamic hasHeartbeatStat, heartbeatStat;
@dynamic hasUseRmq2, useRmq2;
@dynamic hasAccountId, accountId;
@dynamic hasAuthService, authService;
@dynamic hasNetworkType, networkType;
@dynamic hasStatus, status;
@dynamic hasTokenVersionInfo, tokenVersionInfo;
@dynamic hasCellTower, cellTower;
@dynamic hasGcmStartTimeMs, gcmStartTimeMs;
@dynamic clientEventArray, clientEventArray_Count;
@dynamic hasOnFallback, onFallback;
@dynamic hasNoPendingUpstream, noPendingUpstream;
@dynamic hasReconnectRequestId, reconnectRequestId;

typedef struct GtalkLoginRequest__storage_ {
  uint32_t _has_storage_[1];
  GtalkLoginRequest_AuthService authService;
  int32_t networkType;
  int32_t reconnectRequestId;
  NSString *id_p;
  NSString *domain;
  NSString *user;
  NSString *resource;
  NSString *authToken;
  NSString *deviceId;
  NSMutableArray *settingArray;
  NSMutableArray *receivedPersistentIdArray;
  GtalkHeartbeatStat *heartbeatStat;
  NSString *tokenVersionInfo;
  GtalkCellTower *cellTower;
  NSMutableArray *clientEventArray;
  int64_t lastRmqId;
  int64_t accountId;
  int64_t status;
  uint64_t gcmStartTimeMs;
} GtalkLoginRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domain",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_Domain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, domain),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_User,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, user),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "resource",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_Resource,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, resource),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authToken",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_AuthToken,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, authToken),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_DeviceId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastRmqId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_LastRmqId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, lastRmqId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "settingArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkSetting),
        .number = GtalkLoginRequest_FieldNumber_SettingArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, settingArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "receivedPersistentIdArray",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_ReceivedPersistentIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, receivedPersistentIdArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "includeStreamIds",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_IncludeStreamIds,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "heartbeatStat",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkHeartbeatStat),
        .number = GtalkLoginRequest_FieldNumber_HeartbeatStat,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, heartbeatStat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "useRmq2",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_UseRmq2,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_AccountId,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "authService",
        .dataTypeSpecific.enumDescFunc = GtalkLoginRequest_AuthService_EnumDescriptor,
        .number = GtalkLoginRequest_FieldNumber_AuthService,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, authService),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "networkType",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_NetworkType,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, networkType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_Status,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tokenVersionInfo",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_TokenVersionInfo,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, tokenVersionInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cellTower",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkCellTower),
        .number = GtalkLoginRequest_FieldNumber_CellTower,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, cellTower),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gcmStartTimeMs",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_GcmStartTimeMs,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, gcmStartTimeMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "clientEventArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkClientEvent),
        .number = GtalkLoginRequest_FieldNumber_ClientEventArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, clientEventArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "onFallback",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_OnFallback,
        .hasIndex = 19,
        .offset = 20,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "noPendingUpstream",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_NoPendingUpstream,
        .hasIndex = 21,
        .offset = 22,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "reconnectRequestId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginRequest_FieldNumber_ReconnectRequestId,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(GtalkLoginRequest__storage_, reconnectRequestId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkLoginRequest class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkLoginRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum GtalkLoginRequest_AuthService

GPBEnumDescriptor *GtalkLoginRequest_AuthService_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Mail\000AndroidCloudToDeviceMessage\000Android"
        "Id\000";
    static const int32_t values[] = {
        GtalkLoginRequest_AuthService_Mail,
        GtalkLoginRequest_AuthService_AndroidCloudToDeviceMessage,
        GtalkLoginRequest_AuthService_AndroidId,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GtalkLoginRequest_AuthService)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GtalkLoginRequest_AuthService_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GtalkLoginRequest_AuthService_IsValidValue(int32_t value__) {
  switch (value__) {
    case GtalkLoginRequest_AuthService_Mail:
    case GtalkLoginRequest_AuthService_AndroidCloudToDeviceMessage:
    case GtalkLoginRequest_AuthService_AndroidId:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GtalkLoginResponse

@implementation GtalkLoginResponse

@dynamic hasId_p, id_p;
@dynamic hasJid, jid;
@dynamic hasError, error;
@dynamic settingArray, settingArray_Count;
@dynamic hasStreamId, streamId;
@dynamic hasLastStreamIdReceived, lastStreamIdReceived;
@dynamic hasHeartbeatConfig, heartbeatConfig;
@dynamic hasServerTimestamp, serverTimestamp;

typedef struct GtalkLoginResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t streamId;
  int32_t lastStreamIdReceived;
  NSString *id_p;
  NSString *jid;
  GtalkErrorInfo *error;
  NSMutableArray *settingArray;
  GtalkHeartbeatConfig *heartbeatConfig;
  int64_t serverTimestamp;
} GtalkLoginResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginResponse_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkLoginResponse__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jid",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginResponse_FieldNumber_Jid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkLoginResponse__storage_, jid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkErrorInfo),
        .number = GtalkLoginResponse_FieldNumber_Error,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkLoginResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "settingArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkSetting),
        .number = GtalkLoginResponse_FieldNumber_SettingArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GtalkLoginResponse__storage_, settingArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "streamId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginResponse_FieldNumber_StreamId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkLoginResponse__storage_, streamId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastStreamIdReceived",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginResponse_FieldNumber_LastStreamIdReceived,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GtalkLoginResponse__storage_, lastStreamIdReceived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "heartbeatConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkHeartbeatConfig),
        .number = GtalkLoginResponse_FieldNumber_HeartbeatConfig,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GtalkLoginResponse__storage_, heartbeatConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serverTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = GtalkLoginResponse_FieldNumber_ServerTimestamp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GtalkLoginResponse__storage_, serverTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkLoginResponse class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkLoginResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkBindAccountRequest

@implementation GtalkBindAccountRequest

@dynamic hasId_p, id_p;
@dynamic hasDomain, domain;
@dynamic hasUser, user;
@dynamic hasResource, resource;
@dynamic hasAuthToken, authToken;
@dynamic hasPersistentId, persistentId;
@dynamic hasStreamId, streamId;
@dynamic hasLastStreamIdReceived, lastStreamIdReceived;
@dynamic hasAccountId, accountId;

typedef struct GtalkBindAccountRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t streamId;
  int32_t lastStreamIdReceived;
  NSString *id_p;
  NSString *domain;
  NSString *user;
  NSString *resource;
  NSString *authToken;
  NSString *persistentId;
  int64_t accountId;
} GtalkBindAccountRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBindAccountRequest_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkBindAccountRequest__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domain",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBindAccountRequest_FieldNumber_Domain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkBindAccountRequest__storage_, domain),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBindAccountRequest_FieldNumber_User,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkBindAccountRequest__storage_, user),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "resource",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBindAccountRequest_FieldNumber_Resource,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkBindAccountRequest__storage_, resource),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authToken",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBindAccountRequest_FieldNumber_AuthToken,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GtalkBindAccountRequest__storage_, authToken),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "persistentId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBindAccountRequest_FieldNumber_PersistentId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GtalkBindAccountRequest__storage_, persistentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "streamId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBindAccountRequest_FieldNumber_StreamId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GtalkBindAccountRequest__storage_, streamId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastStreamIdReceived",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBindAccountRequest_FieldNumber_LastStreamIdReceived,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GtalkBindAccountRequest__storage_, lastStreamIdReceived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBindAccountRequest_FieldNumber_AccountId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GtalkBindAccountRequest__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkBindAccountRequest class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkBindAccountRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkBindAccountResponse

@implementation GtalkBindAccountResponse

@dynamic hasId_p, id_p;
@dynamic hasJid, jid;
@dynamic hasError, error;
@dynamic hasStreamId, streamId;
@dynamic hasLastStreamIdReceived, lastStreamIdReceived;

typedef struct GtalkBindAccountResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t streamId;
  int32_t lastStreamIdReceived;
  NSString *id_p;
  NSString *jid;
  GtalkErrorInfo *error;
} GtalkBindAccountResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBindAccountResponse_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkBindAccountResponse__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jid",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBindAccountResponse_FieldNumber_Jid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkBindAccountResponse__storage_, jid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkErrorInfo),
        .number = GtalkBindAccountResponse_FieldNumber_Error,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkBindAccountResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "streamId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBindAccountResponse_FieldNumber_StreamId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkBindAccountResponse__storage_, streamId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastStreamIdReceived",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBindAccountResponse_FieldNumber_LastStreamIdReceived,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GtalkBindAccountResponse__storage_, lastStreamIdReceived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkBindAccountResponse class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkBindAccountResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkStreamErrorStanza

@implementation GtalkStreamErrorStanza

@dynamic hasType, type;
@dynamic hasText, text;

typedef struct GtalkStreamErrorStanza__storage_ {
  uint32_t _has_storage_[1];
  NSString *type;
  NSString *text;
} GtalkStreamErrorStanza__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = GtalkStreamErrorStanza_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkStreamErrorStanza__storage_, type),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = GtalkStreamErrorStanza_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkStreamErrorStanza__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkStreamErrorStanza class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkStreamErrorStanza__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkClose

@implementation GtalkClose


typedef struct GtalkClose__storage_ {
  uint32_t _has_storage_[1];
} GtalkClose__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkClose class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GtalkClose__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkExtension

@implementation GtalkExtension

@dynamic hasId_p, id_p;
@dynamic hasData_p, data_p;

typedef struct GtalkExtension__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSString *data_p;
} GtalkExtension__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GtalkExtension_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkExtension__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = GtalkExtension_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkExtension__storage_, data_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkExtension class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkExtension__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkMessageStanza

@implementation GtalkMessageStanza

@dynamic hasRmqId, rmqId;
@dynamic hasType, type;
@dynamic hasId_p, id_p;
@dynamic hasFrom, from;
@dynamic hasTo, to;
@dynamic hasSubject, subject;
@dynamic hasBody, body;
@dynamic hasThread, thread;
@dynamic hasError, error;
@dynamic extensionArray, extensionArray_Count;
@dynamic hasNosave, nosave;
@dynamic hasTimestamp, timestamp;
@dynamic hasPersistentId, persistentId;
@dynamic hasStreamId, streamId;
@dynamic hasLastStreamIdReceived, lastStreamIdReceived;
@dynamic hasRead, read;
@dynamic hasAccountId, accountId;

typedef struct GtalkMessageStanza__storage_ {
  uint32_t _has_storage_[1];
  GtalkMessageStanza_MessageType type;
  int32_t streamId;
  int32_t lastStreamIdReceived;
  NSString *id_p;
  NSString *from;
  NSString *to;
  NSString *subject;
  NSString *body;
  NSString *thread;
  GtalkErrorInfo *error;
  NSMutableArray *extensionArray;
  NSString *persistentId;
  int64_t rmqId;
  int64_t timestamp;
  int64_t accountId;
} GtalkMessageStanza__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rmqId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkMessageStanza_FieldNumber_RmqId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkMessageStanza__storage_, rmqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = GtalkMessageStanza_MessageType_EnumDescriptor,
        .number = GtalkMessageStanza_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkMessageStanza__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GtalkMessageStanza_FieldNumber_Id_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkMessageStanza__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = GtalkMessageStanza_FieldNumber_From,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkMessageStanza__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "to",
        .dataTypeSpecific.className = NULL,
        .number = GtalkMessageStanza_FieldNumber_To,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GtalkMessageStanza__storage_, to),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subject",
        .dataTypeSpecific.className = NULL,
        .number = GtalkMessageStanza_FieldNumber_Subject,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GtalkMessageStanza__storage_, subject),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = NULL,
        .number = GtalkMessageStanza_FieldNumber_Body,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GtalkMessageStanza__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thread",
        .dataTypeSpecific.className = NULL,
        .number = GtalkMessageStanza_FieldNumber_Thread,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GtalkMessageStanza__storage_, thread),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkErrorInfo),
        .number = GtalkMessageStanza_FieldNumber_Error,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GtalkMessageStanza__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extensionArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkExtension),
        .number = GtalkMessageStanza_FieldNumber_ExtensionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GtalkMessageStanza__storage_, extensionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nosave",
        .dataTypeSpecific.className = NULL,
        .number = GtalkMessageStanza_FieldNumber_Nosave,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = GtalkMessageStanza_FieldNumber_Timestamp,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(GtalkMessageStanza__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "persistentId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkMessageStanza_FieldNumber_PersistentId,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(GtalkMessageStanza__storage_, persistentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "streamId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkMessageStanza_FieldNumber_StreamId,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(GtalkMessageStanza__storage_, streamId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastStreamIdReceived",
        .dataTypeSpecific.className = NULL,
        .number = GtalkMessageStanza_FieldNumber_LastStreamIdReceived,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(GtalkMessageStanza__storage_, lastStreamIdReceived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "read",
        .dataTypeSpecific.className = NULL,
        .number = GtalkMessageStanza_FieldNumber_Read,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkMessageStanza_FieldNumber_AccountId,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(GtalkMessageStanza__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkMessageStanza class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkMessageStanza__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum GtalkMessageStanza_MessageType

GPBEnumDescriptor *GtalkMessageStanza_MessageType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Normal\000Chat\000Groupchat\000Headline\000Error\000";
    static const int32_t values[] = {
        GtalkMessageStanza_MessageType_Normal,
        GtalkMessageStanza_MessageType_Chat,
        GtalkMessageStanza_MessageType_Groupchat,
        GtalkMessageStanza_MessageType_Headline,
        GtalkMessageStanza_MessageType_Error,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GtalkMessageStanza_MessageType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GtalkMessageStanza_MessageType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GtalkMessageStanza_MessageType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GtalkMessageStanza_MessageType_Normal:
    case GtalkMessageStanza_MessageType_Chat:
    case GtalkMessageStanza_MessageType_Groupchat:
    case GtalkMessageStanza_MessageType_Headline:
    case GtalkMessageStanza_MessageType_Error:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GtalkPresenceStanza

@implementation GtalkPresenceStanza

@dynamic hasRmqId, rmqId;
@dynamic hasType, type;
@dynamic hasId_p, id_p;
@dynamic hasFrom, from;
@dynamic hasTo, to;
@dynamic hasShow, show;
@dynamic hasStatus, status;
@dynamic hasPriority, priority;
@dynamic hasError, error;
@dynamic extensionArray, extensionArray_Count;
@dynamic hasClient, client;
@dynamic hasAvatarHash, avatarHash;
@dynamic hasPersistentId, persistentId;
@dynamic hasStreamId, streamId;
@dynamic hasLastStreamIdReceived, lastStreamIdReceived;
@dynamic hasCapabilitiesFlags, capabilitiesFlags;
@dynamic hasAccountId, accountId;

typedef struct GtalkPresenceStanza__storage_ {
  uint32_t _has_storage_[1];
  GtalkPresenceStanza_PresenceType type;
  GtalkPresenceStanza_ShowType show;
  int32_t priority;
  GtalkPresenceStanza_ClientType client;
  int32_t streamId;
  int32_t lastStreamIdReceived;
  int32_t capabilitiesFlags;
  NSString *id_p;
  NSString *from;
  NSString *to;
  NSString *status;
  GtalkErrorInfo *error;
  NSMutableArray *extensionArray;
  NSString *avatarHash;
  NSString *persistentId;
  int64_t rmqId;
  int64_t accountId;
} GtalkPresenceStanza__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rmqId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPresenceStanza_FieldNumber_RmqId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, rmqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = GtalkPresenceStanza_PresenceType_EnumDescriptor,
        .number = GtalkPresenceStanza_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPresenceStanza_FieldNumber_Id_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPresenceStanza_FieldNumber_From,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "to",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPresenceStanza_FieldNumber_To,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, to),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "show",
        .dataTypeSpecific.enumDescFunc = GtalkPresenceStanza_ShowType_EnumDescriptor,
        .number = GtalkPresenceStanza_FieldNumber_Show,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, show),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPresenceStanza_FieldNumber_Status,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "priority",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPresenceStanza_FieldNumber_Priority,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, priority),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkErrorInfo),
        .number = GtalkPresenceStanza_FieldNumber_Error,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extensionArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkExtension),
        .number = GtalkPresenceStanza_FieldNumber_ExtensionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, extensionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "client",
        .dataTypeSpecific.enumDescFunc = GtalkPresenceStanza_ClientType_EnumDescriptor,
        .number = GtalkPresenceStanza_FieldNumber_Client,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, client),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "avatarHash",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPresenceStanza_FieldNumber_AvatarHash,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, avatarHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "persistentId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPresenceStanza_FieldNumber_PersistentId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, persistentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "streamId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPresenceStanza_FieldNumber_StreamId,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, streamId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastStreamIdReceived",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPresenceStanza_FieldNumber_LastStreamIdReceived,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, lastStreamIdReceived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "capabilitiesFlags",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPresenceStanza_FieldNumber_CapabilitiesFlags,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, capabilitiesFlags),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkPresenceStanza_FieldNumber_AccountId,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(GtalkPresenceStanza__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkPresenceStanza class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkPresenceStanza__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum GtalkPresenceStanza_PresenceType

GPBEnumDescriptor *GtalkPresenceStanza_PresenceType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unavailable\000Subscribe\000Subscribed\000Unsubsc"
        "ribe\000Unsubscribed\000Probe\000Error\000";
    static const int32_t values[] = {
        GtalkPresenceStanza_PresenceType_Unavailable,
        GtalkPresenceStanza_PresenceType_Subscribe,
        GtalkPresenceStanza_PresenceType_Subscribed,
        GtalkPresenceStanza_PresenceType_Unsubscribe,
        GtalkPresenceStanza_PresenceType_Unsubscribed,
        GtalkPresenceStanza_PresenceType_Probe,
        GtalkPresenceStanza_PresenceType_Error,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GtalkPresenceStanza_PresenceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GtalkPresenceStanza_PresenceType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GtalkPresenceStanza_PresenceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GtalkPresenceStanza_PresenceType_Unavailable:
    case GtalkPresenceStanza_PresenceType_Subscribe:
    case GtalkPresenceStanza_PresenceType_Subscribed:
    case GtalkPresenceStanza_PresenceType_Unsubscribe:
    case GtalkPresenceStanza_PresenceType_Unsubscribed:
    case GtalkPresenceStanza_PresenceType_Probe:
    case GtalkPresenceStanza_PresenceType_Error:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GtalkPresenceStanza_ShowType

GPBEnumDescriptor *GtalkPresenceStanza_ShowType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Away\000Chat\000Dnd\000Xa\000";
    static const int32_t values[] = {
        GtalkPresenceStanza_ShowType_Away,
        GtalkPresenceStanza_ShowType_Chat,
        GtalkPresenceStanza_ShowType_Dnd,
        GtalkPresenceStanza_ShowType_Xa,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GtalkPresenceStanza_ShowType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GtalkPresenceStanza_ShowType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GtalkPresenceStanza_ShowType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GtalkPresenceStanza_ShowType_Away:
    case GtalkPresenceStanza_ShowType_Chat:
    case GtalkPresenceStanza_ShowType_Dnd:
    case GtalkPresenceStanza_ShowType_Xa:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GtalkPresenceStanza_ClientType

GPBEnumDescriptor *GtalkPresenceStanza_ClientType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Mobile\000Android\000";
    static const int32_t values[] = {
        GtalkPresenceStanza_ClientType_Mobile,
        GtalkPresenceStanza_ClientType_Android,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GtalkPresenceStanza_ClientType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GtalkPresenceStanza_ClientType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GtalkPresenceStanza_ClientType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GtalkPresenceStanza_ClientType_Mobile:
    case GtalkPresenceStanza_ClientType_Android:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GtalkPresenceStanza_CapabilitiesFlags

GPBEnumDescriptor *GtalkPresenceStanza_CapabilitiesFlags_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "HasVoiceV1\000HasVideoV1\000HasCameraV1\000HasPmu"
        "cV1\000";
    static const int32_t values[] = {
        GtalkPresenceStanza_CapabilitiesFlags_HasVoiceV1,
        GtalkPresenceStanza_CapabilitiesFlags_HasVideoV1,
        GtalkPresenceStanza_CapabilitiesFlags_HasCameraV1,
        GtalkPresenceStanza_CapabilitiesFlags_HasPmucV1,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GtalkPresenceStanza_CapabilitiesFlags)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GtalkPresenceStanza_CapabilitiesFlags_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GtalkPresenceStanza_CapabilitiesFlags_IsValidValue(int32_t value__) {
  switch (value__) {
    case GtalkPresenceStanza_CapabilitiesFlags_HasVoiceV1:
    case GtalkPresenceStanza_CapabilitiesFlags_HasVideoV1:
    case GtalkPresenceStanza_CapabilitiesFlags_HasCameraV1:
    case GtalkPresenceStanza_CapabilitiesFlags_HasPmucV1:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GtalkBatchPresenceStanza

@implementation GtalkBatchPresenceStanza

@dynamic hasId_p, id_p;
@dynamic hasTo, to;
@dynamic presenceArray, presenceArray_Count;
@dynamic hasPersistentId, persistentId;
@dynamic hasStreamId, streamId;
@dynamic hasLastStreamIdReceived, lastStreamIdReceived;
@dynamic hasAccountId, accountId;
@dynamic hasType, type;
@dynamic hasError, error;

typedef struct GtalkBatchPresenceStanza__storage_ {
  uint32_t _has_storage_[1];
  int32_t streamId;
  int32_t lastStreamIdReceived;
  GtalkBatchPresenceStanza_Type type;
  NSString *id_p;
  NSString *to;
  NSMutableArray *presenceArray;
  NSString *persistentId;
  GtalkErrorInfo *error;
  int64_t accountId;
} GtalkBatchPresenceStanza__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBatchPresenceStanza_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkBatchPresenceStanza__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "to",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBatchPresenceStanza_FieldNumber_To,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkBatchPresenceStanza__storage_, to),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "presenceArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkPresenceStanza),
        .number = GtalkBatchPresenceStanza_FieldNumber_PresenceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GtalkBatchPresenceStanza__storage_, presenceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "persistentId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBatchPresenceStanza_FieldNumber_PersistentId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkBatchPresenceStanza__storage_, persistentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "streamId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBatchPresenceStanza_FieldNumber_StreamId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkBatchPresenceStanza__storage_, streamId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastStreamIdReceived",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBatchPresenceStanza_FieldNumber_LastStreamIdReceived,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GtalkBatchPresenceStanza__storage_, lastStreamIdReceived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkBatchPresenceStanza_FieldNumber_AccountId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GtalkBatchPresenceStanza__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = GtalkBatchPresenceStanza_Type_EnumDescriptor,
        .number = GtalkBatchPresenceStanza_FieldNumber_Type,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GtalkBatchPresenceStanza__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkErrorInfo),
        .number = GtalkBatchPresenceStanza_FieldNumber_Error,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GtalkBatchPresenceStanza__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkBatchPresenceStanza class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkBatchPresenceStanza__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum GtalkBatchPresenceStanza_Type

GPBEnumDescriptor *GtalkBatchPresenceStanza_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Get\000Set\000";
    static const int32_t values[] = {
        GtalkBatchPresenceStanza_Type_Get,
        GtalkBatchPresenceStanza_Type_Set,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GtalkBatchPresenceStanza_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GtalkBatchPresenceStanza_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GtalkBatchPresenceStanza_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case GtalkBatchPresenceStanza_Type_Get:
    case GtalkBatchPresenceStanza_Type_Set:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GtalkIqStanza

@implementation GtalkIqStanza

@dynamic hasRmqId, rmqId;
@dynamic hasType, type;
@dynamic hasId_p, id_p;
@dynamic hasFrom, from;
@dynamic hasTo, to;
@dynamic hasError, error;
@dynamic hasExtension, extension;
@dynamic hasPersistentId, persistentId;
@dynamic hasStreamId, streamId;
@dynamic hasLastStreamIdReceived, lastStreamIdReceived;
@dynamic hasAccountId, accountId;
@dynamic hasStatus, status;

typedef struct GtalkIqStanza__storage_ {
  uint32_t _has_storage_[1];
  GtalkIqStanza_IqType type;
  int32_t streamId;
  int32_t lastStreamIdReceived;
  NSString *id_p;
  NSString *from;
  NSString *to;
  GtalkErrorInfo *error;
  GtalkExtension *extension;
  NSString *persistentId;
  int64_t rmqId;
  int64_t accountId;
  int64_t status;
} GtalkIqStanza__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rmqId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkIqStanza_FieldNumber_RmqId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkIqStanza__storage_, rmqId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = GtalkIqStanza_IqType_EnumDescriptor,
        .number = GtalkIqStanza_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkIqStanza__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GtalkIqStanza_FieldNumber_Id_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkIqStanza__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = GtalkIqStanza_FieldNumber_From,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkIqStanza__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "to",
        .dataTypeSpecific.className = NULL,
        .number = GtalkIqStanza_FieldNumber_To,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GtalkIqStanza__storage_, to),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkErrorInfo),
        .number = GtalkIqStanza_FieldNumber_Error,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GtalkIqStanza__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extension",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkExtension),
        .number = GtalkIqStanza_FieldNumber_Extension,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GtalkIqStanza__storage_, extension),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "persistentId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkIqStanza_FieldNumber_PersistentId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GtalkIqStanza__storage_, persistentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "streamId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkIqStanza_FieldNumber_StreamId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GtalkIqStanza__storage_, streamId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastStreamIdReceived",
        .dataTypeSpecific.className = NULL,
        .number = GtalkIqStanza_FieldNumber_LastStreamIdReceived,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(GtalkIqStanza__storage_, lastStreamIdReceived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkIqStanza_FieldNumber_AccountId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(GtalkIqStanza__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = GtalkIqStanza_FieldNumber_Status,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(GtalkIqStanza__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkIqStanza class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkIqStanza__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum GtalkIqStanza_IqType

GPBEnumDescriptor *GtalkIqStanza_IqType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Get\000Set\000Result\000Error\000";
    static const int32_t values[] = {
        GtalkIqStanza_IqType_Get,
        GtalkIqStanza_IqType_Set,
        GtalkIqStanza_IqType_Result,
        GtalkIqStanza_IqType_Error,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GtalkIqStanza_IqType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GtalkIqStanza_IqType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GtalkIqStanza_IqType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GtalkIqStanza_IqType_Get:
    case GtalkIqStanza_IqType_Set:
    case GtalkIqStanza_IqType_Result:
    case GtalkIqStanza_IqType_Error:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GtalkAppData

@implementation GtalkAppData

@dynamic hasKey, key;
@dynamic hasValue, value;

typedef struct GtalkAppData__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
} GtalkAppData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = GtalkAppData_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkAppData__storage_, key),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = GtalkAppData_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkAppData__storage_, value),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkAppData class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkAppData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkDataMessageStanza

@implementation GtalkDataMessageStanza

@dynamic hasRmqId, rmqId;
@dynamic hasId_p, id_p;
@dynamic hasFrom, from;
@dynamic hasTo, to;
@dynamic hasCategory, category;
@dynamic hasToken, token;
@dynamic appDataArray, appDataArray_Count;
@dynamic hasFromTrustedServer, fromTrustedServer;
@dynamic hasPersistentId, persistentId;
@dynamic hasStreamId, streamId;
@dynamic hasLastStreamIdReceived, lastStreamIdReceived;
@dynamic hasPermission, permission;
@dynamic hasRegId, regId;
@dynamic hasPkgSignature, pkgSignature;
@dynamic hasClientId, clientId;
@dynamic hasDeviceUserId, deviceUserId;
@dynamic hasTtl, ttl;
@dynamic hasSent, sent;
@dynamic hasQueued, queued;
@dynamic hasStatus, status;
@dynamic hasRawData, rawData;
@dynamic hasMaxDelay, maxDelay;
@dynamic hasActualDelay, actualDelay;
@dynamic hasImmediateAck, immediateAck;
@dynamic hasDeliveryReceiptRequested, deliveryReceiptRequested;
@dynamic hasExternalMessageId, externalMessageId;
@dynamic hasFlags, flags;
@dynamic hasCellTower, cellTower;
@dynamic hasPriority, priority;

typedef struct GtalkDataMessageStanza__storage_ {
  uint32_t _has_storage_[1];
  int32_t streamId;
  int32_t lastStreamIdReceived;
  int32_t ttl;
  int32_t queued;
  int32_t maxDelay;
  int32_t actualDelay;
  int32_t priority;
  NSString *id_p;
  NSString *from;
  NSString *to;
  NSString *category;
  NSString *token;
  NSMutableArray *appDataArray;
  NSString *persistentId;
  NSString *permission;
  NSString *regId;
  NSString *pkgSignature;
  NSString *clientId;
  NSData *rawData;
  NSString *externalMessageId;
  GtalkCellTower *cellTower;
  int64_t rmqId;
  int64_t deviceUserId;
  int64_t sent;
  int64_t status;
  int64_t flags;
} GtalkDataMessageStanza__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rmqId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_RmqId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, rmqId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_From,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, from),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "to",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_To,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, to),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_Category,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, category),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_Token,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appDataArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkAppData),
        .number = GtalkDataMessageStanza_FieldNumber_AppDataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, appDataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fromTrustedServer",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_FromTrustedServer,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "persistentId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_PersistentId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, persistentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "streamId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_StreamId,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, streamId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastStreamIdReceived",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_LastStreamIdReceived,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, lastStreamIdReceived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "permission",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_Permission,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, permission),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "regId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_RegId,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, regId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pkgSignature",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_PkgSignature,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, pkgSignature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_ClientId,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, clientId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceUserId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_DeviceUserId,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, deviceUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ttl",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_Ttl,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, ttl),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sent",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_Sent,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, sent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "queued",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_Queued,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, queued),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_Status,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rawData",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_RawData,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, rawData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "maxDelay",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_MaxDelay,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, maxDelay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "actualDelay",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_ActualDelay,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, actualDelay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "immediateAck",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_ImmediateAck,
        .hasIndex = 23,
        .offset = 24,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "deliveryReceiptRequested",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_DeliveryReceiptRequested,
        .hasIndex = 25,
        .offset = 26,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "externalMessageId",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_ExternalMessageId,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, externalMessageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "flags",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_Flags,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, flags),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cellTower",
        .dataTypeSpecific.className = GPBStringifySymbol(GtalkCellTower),
        .number = GtalkDataMessageStanza_FieldNumber_CellTower,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, cellTower),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "priority",
        .dataTypeSpecific.className = NULL,
        .number = GtalkDataMessageStanza_FieldNumber_Priority,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(GtalkDataMessageStanza__storage_, priority),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkDataMessageStanza class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkDataMessageStanza__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkTalkMetadata

@implementation GtalkTalkMetadata

@dynamic hasForeground, foreground;

typedef struct GtalkTalkMetadata__storage_ {
  uint32_t _has_storage_[1];
} GtalkTalkMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "foreground",
        .dataTypeSpecific.className = NULL,
        .number = GtalkTalkMetadata_FieldNumber_Foreground,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkTalkMetadata class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkTalkMetadata__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GtalkCellTower

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-implementations"

@implementation GtalkCellTower

@dynamic hasId_p, id_p;
@dynamic hasKnownCongestionStatus, knownCongestionStatus;

typedef struct GtalkCellTower__storage_ {
  uint32_t _has_storage_[1];
  int32_t knownCongestionStatus;
  NSString *id_p;
} GtalkCellTower__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GtalkCellTower_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkCellTower__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "knownCongestionStatus",
        .dataTypeSpecific.className = NULL,
        .number = GtalkCellTower_FieldNumber_KnownCongestionStatus,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkCellTower__storage_, knownCongestionStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkCellTower class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkCellTower__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma clang diagnostic pop

#pragma mark - GtalkClientEvent

@implementation GtalkClientEvent

@dynamic hasType, type;
@dynamic hasNumberDiscardedEvents, numberDiscardedEvents;
@dynamic hasNetworkType, networkType;
@dynamic hasNetworkPort, networkPort;
@dynamic hasTimeConnectionStartedMs, timeConnectionStartedMs;
@dynamic hasTimeConnectionEndedMs, timeConnectionEndedMs;
@dynamic hasErrorCode, errorCode;
@dynamic hasTimeConnectionEstablishedMs, timeConnectionEstablishedMs;
@dynamic hasMcsReconnectAction, mcsReconnectAction;

typedef struct GtalkClientEvent__storage_ {
  uint32_t _has_storage_[1];
  GtalkClientEvent_Type type;
  uint32_t numberDiscardedEvents;
  int32_t networkType;
  int32_t networkPort;
  int32_t errorCode;
  GtalkClientEvent_McsReconnectAction mcsReconnectAction;
  uint64_t timeConnectionStartedMs;
  uint64_t timeConnectionEndedMs;
  uint64_t timeConnectionEstablishedMs;
} GtalkClientEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = GtalkClientEvent_Type_EnumDescriptor,
        .number = GtalkClientEvent_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GtalkClientEvent__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "numberDiscardedEvents",
        .dataTypeSpecific.className = NULL,
        .number = GtalkClientEvent_FieldNumber_NumberDiscardedEvents,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GtalkClientEvent__storage_, numberDiscardedEvents),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "networkType",
        .dataTypeSpecific.className = NULL,
        .number = GtalkClientEvent_FieldNumber_NetworkType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GtalkClientEvent__storage_, networkType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "networkPort",
        .dataTypeSpecific.className = NULL,
        .number = GtalkClientEvent_FieldNumber_NetworkPort,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GtalkClientEvent__storage_, networkPort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeConnectionStartedMs",
        .dataTypeSpecific.className = NULL,
        .number = GtalkClientEvent_FieldNumber_TimeConnectionStartedMs,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GtalkClientEvent__storage_, timeConnectionStartedMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "timeConnectionEndedMs",
        .dataTypeSpecific.className = NULL,
        .number = GtalkClientEvent_FieldNumber_TimeConnectionEndedMs,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GtalkClientEvent__storage_, timeConnectionEndedMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "errorCode",
        .dataTypeSpecific.className = NULL,
        .number = GtalkClientEvent_FieldNumber_ErrorCode,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GtalkClientEvent__storage_, errorCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeConnectionEstablishedMs",
        .dataTypeSpecific.className = NULL,
        .number = GtalkClientEvent_FieldNumber_TimeConnectionEstablishedMs,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GtalkClientEvent__storage_, timeConnectionEstablishedMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "mcsReconnectAction",
        .dataTypeSpecific.enumDescFunc = GtalkClientEvent_McsReconnectAction_EnumDescriptor,
        .number = GtalkClientEvent_FieldNumber_McsReconnectAction,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GtalkClientEvent__storage_, mcsReconnectAction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GtalkClientEvent class]
                                     rootClass:[GtalkGtalkCoreRoot class]
                                          file:GtalkGtalkCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GtalkClientEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum GtalkClientEvent_Type

GPBEnumDescriptor *GtalkClientEvent_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000DiscardedEvents\000FailedConnection"
        "\000SuccessfulConnection\000McsReconnectReques"
        "t\000FailedSocketCreationMcsReconnect\000McsRe"
        "connectLimited\000";
    static const int32_t values[] = {
        GtalkClientEvent_Type_Unknown,
        GtalkClientEvent_Type_DiscardedEvents,
        GtalkClientEvent_Type_FailedConnection,
        GtalkClientEvent_Type_SuccessfulConnection,
        GtalkClientEvent_Type_McsReconnectRequest,
        GtalkClientEvent_Type_FailedSocketCreationMcsReconnect,
        GtalkClientEvent_Type_McsReconnectLimited,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GtalkClientEvent_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GtalkClientEvent_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GtalkClientEvent_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case GtalkClientEvent_Type_Unknown:
    case GtalkClientEvent_Type_DiscardedEvents:
    case GtalkClientEvent_Type_FailedConnection:
    case GtalkClientEvent_Type_SuccessfulConnection:
    case GtalkClientEvent_Type_McsReconnectRequest:
    case GtalkClientEvent_Type_FailedSocketCreationMcsReconnect:
    case GtalkClientEvent_Type_McsReconnectLimited:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GtalkClientEvent_McsReconnectAction

GPBEnumDescriptor *GtalkClientEvent_McsReconnectAction_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000NotConnected\000TooSoon\000";
    static const int32_t values[] = {
        GtalkClientEvent_McsReconnectAction_None,
        GtalkClientEvent_McsReconnectAction_NotConnected,
        GtalkClientEvent_McsReconnectAction_TooSoon,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GtalkClientEvent_McsReconnectAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GtalkClientEvent_McsReconnectAction_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GtalkClientEvent_McsReconnectAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case GtalkClientEvent_McsReconnectAction_None:
    case GtalkClientEvent_McsReconnectAction_NotConnected:
    case GtalkClientEvent_McsReconnectAction_TooSoon:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
